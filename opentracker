#!/bin/sh

### BEGIN INIT INFO
# Provides:           opentracker
# Required-Start:     $network $syslog
# Required-Stop:      $network $syslog
# Default-Start:      2 3 4 5
# Default-Stop:       0 1 6
# Short-Description:  Opentracker LSB init script
# Description:        Opentracker Linux Standards Base compliant init script.
### END INIT INFO

# -----------------------------------------------------------------------------
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org>
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Opentracker Linux Standards Base compliant init script.
#
# Exit status codes of this script and their meaning:
#
#    0 = Command succeeded.
#   64 = Super user only.
#   65 = Service binary not installed/found.
#   66 = Incorrect usage.
#
# In some cases the exit code from another command is returned, please refer to
# the documentation of that specific command for information on their meaning.
#
# SEE:        https://wiki.debian.org/LSBInitScripts
# SEE:        http://paste.ubuntu.com/6918156/
#
# AUTHOR:     Richard Fussenegger <richard@fussenegger.info>
# COPYRIGHT:  Copyright (c) 2015 Richard Fussenegger
# LICENSE:    http://unlicense.org/ PD
# -----------------------------------------------------------------------------

# The service's name.
readonly NAME='opentracker'

# The service's deamon arguments.
readonly DAEMON_ARGS='-f /etc/opentracker/opentracker.conf'

# The service's PID file.
readonly PIDFILE='/run/opentracker.pid'

# Load the VERBOSE setting and other rcS variables.
. /lib/init/vars.sh

# Load LSB functions.
. /lib/lsb/init-functions

# Make sure the script is only executed by super users.
if [ $(id -u) -ne 0 ]
then
    [ "${VERBOSE}" != no ] && log_failure_msg "${NAME}" 'super user only!'
    exit 64
fi

# Determine the service daemon's absolute path.
DAEMON=$(type "${NAME}")
if [ ${?} -ne 0 ]
then
    [ "${VERBOSE}" != no ] && log_failure_msg "${NAME}" 'not installed'
    exit 65
fi
DAEMON="${DAEMON##* }"

# Determine the service's status.
#
#   0 = Program is running.
#   1 = Program is not running and the PID file exists.
#   3 = Program is not running.
#   4 = Unable to determine status.
readonly STATUS=$(start-stop-daemon --status --quiet --pidfile "${PIDFILE}" --exec "${DAEMON}")

# Default options for start-stop-daemon command.
readonly START_STOP_DAEMON_ARGS="--quiet --oknodo --pidfil ${PIDFILE} --exec ${DAEMON} --name ${NAME}"

# Handle passed arguments.
case "${1}" in

    force-reload|restart)
        if [ "${STATUS}" = 0 ]
        then
            [ "${VERBOSE}" != no ] && log_daemon_msg "${NAME}" 'reloading configuration'
            start-stop-daemon --stop --signal HUP ${START_STOP_DAEMON_ARGS}
            [ "${VERBOSE}" != no ] && log_end_msg ${?} || exit ${?}
        else
            [ "${VERBOSE}" != no ] && log_failure_msg "${NAME}" 'not running'
        fi
    ;;

    start)
        if [ "${STATUS}" = 0 ]
        then
            [ "${VERBOSE}" != no ] && log_success_msg "${NAME}" 'already running'
        else
            [ "${VERBOSE}" != no ] && log_daemon_msg "${NAME}" 'starting'
            start-stop-daemon --start --oknodo --background --make-pidfile ${START_STOP_DAEMON_ARGS} -- ${DAEMON_ARGS}
            [ "${VERBOSE}" != no ] && log_end_msg ${?} || exit ${?}
        fi
    ;;

    status)
        status_of_proc "${DAEMON}" "${NAME}" && exit 0 || exit ${?}
    ;;

    stop)
        if [ "${STATUS}" = 0 ]
        then
            [ "${VERBOSE}" != no ] && log_daemon_msg "${NAME}" 'stopping'
            start-stop-daemon --stop --retry=TERM/30/KILL/5 ${START_STOP_DAEMON_ARGS}
            [ "${VERBOSE}" != no ] && log_end_msg ${?} || exit ${?}
        else
            if [ -e "${PIDFILE}" ]
                then rm --force -- "${PIDFILE}"
            fi
            [ "${VERBOSE}" != no ] && log_success_msg "${NAME}" 'already stopped'
        fi
    ;;

    *)
        printf -- 'Usage: %s {force-reload|restart|start|status|stop}\n' "/etc/init.d/${NAME}" >&2
        exit 66
    ;;

esac

exit 0
